import { GoogleGenAI, GenerateContentResponse, Modality, Type } from "@google/genai";
import { ApiKeyStatus } from "../types";

/**
 * Generates an image from a text prompt, optionally using a reference image, supporting multiple AI models.
 * @param apiKey The API key to use for this request.
 * @param prompt The detailed text prompt for image generation.
 * @param model The AI model to use ('gemini-2.5-flash-image-preview' or 'imagen-4.0-generate-001').
 * @param imageBase64 The base64 encoded reference image string (optional, only for Gemini).
 * @param mimeType The MIME type of the reference image (optional, only for Gemini).
 * @returns A promise that resolves to a base64 encoded image URL.
 */
export async function generateImage(apiKey: string, prompt: string, model: string, imageBase64?: string, mimeType?: string): Promise<string> {
    try {
        const genAI = new GoogleGenAI(apiKey);

        if (model === 'imagen-4.0-generate-001') {
            if (imageBase64) {
                throw new Error("Model 'imagen-4.0-generate-001' does not support reference images.");
            }
            
            const imageModel = genAI.getGenerativeModel({ model: 'imagen-3.0-generate-001' });
            const result = await imageModel.generateContent({
                contents: [{
                    parts: [{ text: prompt }]
                }],
                generationConfig: {
                    responseMimeType: "image/jpeg"
                }
            });
            
            const response = await result.response;
            const imagePart = response.candidates?.[0]?.content?.parts?.find(
                (part: any) => part.inlineData?.mimeType?.startsWith('image/')
            );
            
            if (imagePart?.inlineData?.data) {
                return `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
            }
            
            throw new Error('No image was generated by imagen model.');
            
        } else if (model === 'gemini-2.5-flash-image-preview') {
            const imageModel = genAI.getGenerativeModel({ 
                model: 'gemini-2.5-flash-image-preview',
                generationConfig: {
                    responseMimeType: "image/jpeg"
                }
            });
            
            const parts: any[] = [];
            
            if (imageBase64 && mimeType) {
                parts.push({
                    inlineData: {
                        data: imageBase64,
                        mimeType: mimeType
                    }
                });
            }
            
            parts.push({ text: prompt });
            
            const result = await imageModel.generateContent({
                contents: [{
                    parts: parts
                }]
            });
            
            const response = await result.response;
            const imagePart = response.candidates?.[0]?.content?.parts?.find(
                (part: any) => part.inlineData?.mimeType?.startsWith('image/')
            );
            
            if (imagePart?.inlineData?.data) {
                return `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
            }
            
            // Check for text response that might indicate an error
            const textPart = response.candidates?.[0]?.content?.parts?.find(
                (part: any) => part.text
            );
            
            if (textPart?.text) {
                throw new Error(`Image generation failed: ${textPart.text}`);
            }
            
            throw new Error('No image was generated by the API.');
        } else {
            throw new Error(`Unsupported model selected: ${model}`);
        }

    } catch (error) {
        console.error("Error generating image with AI API:", error);
        
        // Check for specific error types
        const errorMessage = error instanceof Error ? error.message : String(error);
        
        if (errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('RESOURCE_EXHAUSTED')) {
            throw new Error('API quota exhausted. Please try again later or use a different API key.');
        }
        
        if (errorMessage.includes('403') || errorMessage.includes('API key not valid')) {
            throw new Error('Invalid API key. Please check your API key and try again.');
        }
        
        if (errorMessage.includes('safety') || errorMessage.includes('blocked')) {
            throw new Error('Image generation was blocked by safety filters. Please try a different prompt.');
        }
        
        throw new Error(`Failed to generate image: ${errorMessage}`);
    }
}


/**
 * Generates a text response from a text prompt.
 * @param apiKey The API key to use for this request.
 * @param prompt The text prompt for text generation.
 * @returns A promise that resolves to the generated text string.
 */
export async function generateText(apiKey: string, prompt: string): Promise<string> {
    try {
        const genAI = new GoogleGenAI(apiKey);
        const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        if (!text) {
            throw new Error("API returned an empty text response.");
        }
        return text.trim();

    } catch (error) {
        console.error("Error generating text with AI API:", error);
        throw new Error(`Failed to generate text: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Creates a detailed, consistent physical description of a couple (faces, hair, clothing) to be reused across multiple images.
 * @param apiKey The API key to use for this request.
 * @param userPrompt The user's initial, basic description.
 * @returns A promise that resolves to a detailed and consistent couple description string.
 */
export async function generateConsistentCoupleDescription(apiKey: string, userPrompt: string): Promise<string> {
    try {
        const genAI = new GoogleGenAI(apiKey);
        const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
        
        const prompt = `From the user's prompt, create a detailed, consistent physical description of a young Indonesian couple.
**Crucially, ensure authentic Indonesian features (skin tone, hair, facial structure). Do not describe Caucasian features.**
Focus on specific facial features, hairstyle, and a complete clothing description.
Output a single, cohesive paragraph for AI image generation.
User's prompt: "${userPrompt}"`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        if (!text) {
            throw new Error("API returned an empty text response while creating couple description.");
        }
        return text.trim();

    } catch (error) {
        console.error("Error generating consistent couple description:", error);
        throw new Error(`Failed to generate couple description: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Generates a batch of creative, location-specific scenarios for a photoshoot.
 * @param apiKey The API key to use for this request.
 * @param locationTheme The theme of the photoshoot location (e.g., "Bromo", "Paris").
 * @param count The number of unique scenarios to generate.
 * @returns A promise that resolves to an array of scenario objects.
 */
export async function generateLocationBasedScenarios(apiKey: string, locationTheme: string, count: number): Promise<{ scene: string; emotion: string }[]> {
    const genAI = new GoogleGenAI(apiKey);
    const model = genAI.getGenerativeModel({ 
        model: 'gemini-2.5-flash',
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        scene: {
                            type: Type.STRING,
                            description: 'A specific, vivid action or story moment at the location.',
                        },
                        emotion: {
                            type: Type.STRING,
                            description: 'The core emotion captured in that moment.',
                        },
                    },
                    required: ["scene", "emotion"],
                },
            },
        }
    });
    
    const prompt = `Generate ${count} unique, romantic photo scenarios specific to a photoshoot in "${locationTheme}".
For each, describe a physical action ('scene') and the core 'emotion'. Avoid generic ideas.
Return as a JSON array of objects with "scene" and "emotion" keys.
Example for Bromo: [{ "scene": "Couple huddles in a tenun blanket, watching the sunrise over the crater.", "emotion": "Shared awe and intimacy." }]`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const jsonStr = response.text().trim();
    
    const parsed = JSON.parse(jsonStr);
    if (!Array.isArray(parsed) || parsed.length === 0) {
        throw new Error("Generated scenarios are not in the expected format or are empty.");
    }
    return parsed;
}

/**
 * Validates a single API key by making a simple, low-cost text generation request.
 * Differentiates between invalid keys and keys that have reached their rate limit.
 * @param apiKey The API key to validate.
 * @returns A promise that resolves to an ApiKeyStatus: 'active', 'invalid', or 'exhausted'.
 */
export async function validateApiKey(apiKey: string): Promise<ApiKeyStatus> {
    if (!apiKey || apiKey.trim() === '') {
        return 'invalid';
    }
    
    console.log(`🔍 Validating API key: ${apiKey.slice(0, 8)}...`);
    
    try {
        const genAI = new GoogleGenAI(apiKey);
        const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
        
        // Use a minimal test request with proper configuration
        const result = await model.generateContent({
            contents: [{
                parts: [{ text: 'Hello' }]
            }],
            generationConfig: {
                maxOutputTokens: 5,
                temperature: 0
            }
        });
        
        const response = await result.response;
        
        // Check if we got a valid response
        if (response && (response.candidates || response.text)) {
            console.log('✅ API key validation successful - key is ACTIVE');
            return 'active';
        } else {
            console.log('⚠️ API key validation got empty response');
            return 'invalid';
        }
        
    } catch (error: any) {
        console.error(`❌ API key validation error:`, error);
        
        // More detailed error checking
        const errorMessage = error.message || error.toString() || '';
        const errorStatus = error.status || error.code || '';
        
        console.log(`Error details - Message: "${errorMessage}", Status: "${errorStatus}"`);
        
        // Check for quota exhaustion first
        if (errorMessage.includes('429') || 
            errorMessage.includes('quota') ||
            errorMessage.includes('exceeded') ||
            errorMessage.includes('RESOURCE_EXHAUSTED') ||
            errorStatus === 429) {
            console.log('❌ API key quota exhausted');
            return 'exhausted';
        }
        
        // Check for invalid API key
        if (errorMessage.includes('API key not valid') || 
            errorMessage.includes('invalid') ||
            errorMessage.includes('INVALID_ARGUMENT') ||
            errorMessage.includes('403') ||
            errorStatus === 403 ||
            errorStatus === 400) {
            console.log('❌ API key is invalid');
            return 'invalid';
        }
        
        // For network or other errors, try one more time with direct fetch
        try {
            console.log('🔄 Retrying with direct fetch...');
            const fetchResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: 'test' }]
                    }],
                    generationConfig: {
                        maxOutputTokens: 5
                    }
                })
            });
            
            if (fetchResponse.ok) {
                console.log('✅ Direct fetch validation successful - key is ACTIVE');
                return 'active';
            } else if (fetchResponse.status === 429) {
                console.log('❌ Direct fetch: quota exhausted');
                return 'exhausted';
            } else {
                console.log(`❌ Direct fetch failed: ${fetchResponse.status}`);
                return 'invalid';
            }
        } catch (fetchError) {
            console.log('❌ Direct fetch also failed:', fetchError);
            return 'invalid';
        }
    }
}